# 크레인 인형뽑기 게임

난이도: Level 1
문제 링크: https://school.programmers.co.kr/learn/courses/30/lessons/64061
문제 푼 날짜: 2023/07/20
해결 여부: 문제 해결

## 내가 푼 코드

```python
def solution(board, moves):
    basket = [-1,]
    count = 0
    
    for i in moves:
        for j in range(len(board)):
            if board[j][i-1] != 0:
                basket.append(board[j][i-1])
                board[j][i-1] = 0

                if basket[-1] == basket[-2]:
                    basket.pop()
                    basket.pop()
                    count += 2
                break

    return count
```

## 타인이 푼 코드

### 타인이 푼 방법 1 - 어떻게 푼건지는 모르겠음

```python
def solution(board, moves):
    cols = list(map(lambda x: list(filter(lambda y: y > 0, x)), zip(*board)))
    a, s = 0, [0]

    for m in moves:
        if len(cols[m - 1]) > 0:
            if (d := cols[m - 1].pop(0)) == (l := s.pop()):
                a += 2
            else:
                s.extend([l, d])

    return a
```

2번째 줄을 보면, zip(*board)를 함으로써, 원래 board의 각 원소들은 행을 나타내는 리스트들이었는데, *board를 하니까 각 행을 나타내는 리스트가 그 개수만큼 unpacking되었다. 그렇게 그 각 행을 나타내는 리스트들이 병렬?로 존재하고 있는데 거기에 zip을 하니까, 각 행을 나타내고 있던 리스트들의 앞부분부터 끝부분까지를 하나씩 뱉어낸 걸 모아서 새로운 리스트를 만든다. 한 행의 입장에서 앞부분부터 끝부분까지라는 말은, 1열부터 마지막열까지를 의미한다. 그러므로 각 행들의 1열부터 마지막열까지를 받은 것이므로 zip(*board)는 결국 각 열을 나타내는 리스트들을 가지고 있는 셈이다. 그런데 여기에 map을 통해서 각 열에 대해 lambda를 두 번 사용한 함수를 적용시켜준다. lambda x에서는 열을 나타내는 리스트를 x로 받겠다는 것이고, 열을 나타내는 리스트를 받아서 그 리스트 안에 있는 각각의 값(인형)들을 y로 받아서 0보다 큰 값들만 살려준다. 이 문제에서 0은 인형이 없는 경우이므로 결국에는 2번째 cols = (...)줄을 마치고 나면 cols에는 0번째 원소에는 첫번째 열에 위치한 실재하는 인형들을 나타내는 리스트, 1번째 원소에는 두번째 열을=에 위치한 실재하는 인형들을 나타내는 리스트 이런식으로 넣어지게 된다. 그리고 s는 bucket의 역할을 하고, a는 터뜨려진 인형의 수를 의미한다. s에 처음에 [0]을 넣어주는 이유는 빈 리스트에서 s.pop()을 하면 에러가 발생하므로 그걸 방지하기 위해서 0에 해당하는 인형은 없기 때문에 넣어준 것으로, 에러 발생 방지 이외의 목적은 없다. for m in moves: 안을 살펴보면, cols안의 1번째 열을 나타내는 리스트의 첫번째 원소는 그림 상으로 맨 위에 위치해있던 인형이 있고, 마지막 원소는 가장 바닥에 있어야 할 인형이 있다. 그러므로 cols[m - 1].pop(0)을 하여 위에 있는 것을 빼주는 것이다. s.pop()은 기존의 버킷에서 맨 위에 담겨있던 인형을 꺼내는 것이다. 결국, moves에서 이번에 격자 상에서 가져오는 인형과 버킷의 맨 위에 있던 인형의 값을 비교해준다. 그래서 그 둘이 같으면 인형이 터지는 것이므로 a에 2를 더해주는 것이다. 그런데 그 둘이 다르면, 현재 버킷의 맨 위에 있던 것을 빼왔기 때문에 그 인형이 버킷의 더 깊숙한 곳에 있어야 하므로 l을 앞에 해주고, 이번에 뽑은 인형 d가 뒤에 있어야 하니까 [l, d]로 만들어서 기존의 버킷에 다시 추가해주는 것이다.